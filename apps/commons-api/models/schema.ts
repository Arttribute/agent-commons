// apps/commons-api/src/models/schema.ts
import {
  jsonb,
  pgTable,
  timestamp,
  uuid,
  text,
  integer,
  real,
  boolean as pgBoolean,
} from 'drizzle-orm/pg-core';
import { sql } from 'drizzle-orm';
import { relations } from 'drizzle-orm';
import { ChatCompletionTool } from 'openai/resources';
import { WalletData } from '@coinbase/coinbase-sdk';

/* ─────────────────────────  AGENT  ───────────────────────── */

export const agent = pgTable('agent', {
  agentId: text('agent_id')
    .default(sql`uuid_generate_v4()`)
    .primaryKey(),

  wallet: jsonb().notNull().$type<WalletData>(),
  instructions: text(),
  persona: text(),
  owner: text(),
  name: text().notNull(),
  knowledgebase: jsonb('knowledgebase').$type<
    Array<{
      title: string;
      content: string;
      usageComments?: string;
    }>
  >(),
  externalTools: jsonb('external_tools').$type<string[]>(),
  commonTools: jsonb('common_tools').$type<string[]>(),

  temperature: real('temperature'),
  maxTokens: integer('max_tokens'),
  topP: real('top_p'),
  presencePenalty: real('presence_penalty'),
  frequencyPenalty: real('frequency_penalty'),
  stopSequence: jsonb('stop_sequence').$type<string[]>(),
  avatar: text(),
  // Text-to-speech preferences (optional)
  ttsProvider: text('tts_provider'), // 'openai' | 'elevenlabs'
  ttsVoice: text('tts_voice'), // OpenAI voice name or ElevenLabs voiceId

  // Liaison columns – we store only the hash of the liaison_key
  isLiaison: pgBoolean('is_liaison').default(false).notNull(),
  liaisonKeyHash: text('liaison_key'),
  externalUrl: text('external_url'),
  externalEndpoint: text('external_endpoint'),

  /* ▼ autonomous-mode settings ▼ */
  autonomyEnabled: pgBoolean('autonomy_enabled').default(false).notNull(),
  autonomousIntervalSec: integer('autonomous_interval_sec').default(0), // 0 = off
  cronJobName: text('cron_job_name'),

  createdAt: timestamp('created_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
});

/* ─────────────────────────  SESSION  ───────────────────────── */

export const session = pgTable('session', {
  sessionId: uuid('session_id')
    .default(sql`uuid_generate_v4()`)
    .primaryKey(),

  agentId: text('agent_id').notNull(),

  title: text('title'),
  initiator: text('initiator'), // wallet address of user or agent

  model: jsonb('model').$type<{
    name: string;
    temperature?: number;
    maxTokens?: number;
    topP?: number;
    presencePenalty?: number;
    frequencyPenalty?: number;
  }>(),

  query: jsonb('query').$type<{
    text: string;
    timestamp: string;
    metadata?: Record<string, any>;
  }>(),

  history: jsonb('history').$type<
    Array<{
      role: string;
      content: string;
      timestamp: string;
      metadata?: Record<string, any>;
    }>
  >(),

  metrics: jsonb('metrics').$type<{
    totalTokens?: number;
    responseTime?: number;
    toolCalls?: number;
    errorCount?: number;
  }>(),

  endedAt: timestamp('ended_at', { withTimezone: true }),

  // Keep as JSON list of space IDs for now (not relational)
  spaces: jsonb('spaces').$type<{ spaceIds: string[] }>(),

  // Make this a UUID so we can reference session.sessionId
  parentSessionId: uuid('parent_session'),

  createdAt: timestamp('created_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
});

/* ─────────────────────────  GOAL  ───────────────────────── */

export const goal = pgTable('goal', {
  goalId: uuid('goal_id')
    .default(sql`uuid_generate_v4()`)
    .primaryKey(),

  agentId: text('agent_id')
    .notNull()
    .references(() => agent.agentId, { onDelete: 'cascade' }),

  sessionId: uuid('session_id').references(() => session.sessionId, {
    onDelete: 'cascade',
  }),

  title: text('title').notNull(),
  description: text('description'),

  status: text('status').default('pending').notNull(), // pending | started | paused | completed | failed
  priority: integer('priority').default(0).notNull(),
  deadline: timestamp('deadline', { withTimezone: true }),
  progress: real('progress').default(0),
  isAutoGenerated: pgBoolean('is_auto_generated').default(false),
  metadata: jsonb('metadata').$type<Record<string, any>>(),

  createdAt: timestamp('created_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
  completedAt: timestamp('completed_at', { withTimezone: true }),
});

/* ─────────────────────────  TASK  ───────────────────────── */

export const task = pgTable('task', {
  taskId: uuid('task_id')
    .default(sql`uuid_generate_v4()`)
    .primaryKey(),

  agentId: text('agent_id')
    .notNull()
    .references(() => agent.agentId, { onDelete: 'cascade' }),

  goalId: uuid('goal_id')
    .notNull()
    .references(() => goal.goalId, { onDelete: 'cascade' }),

  sessionId: uuid('session_id').references(() => session.sessionId, {
    onDelete: 'cascade',
  }),

  title: text('title').notNull(),
  description: text('description'),

  status: text('status').default('pending').notNull(), // pending | started | …
  priority: integer('priority').default(0).notNull(),

  scheduledStart: timestamp('scheduled_start', { withTimezone: true }),
  scheduledEnd: timestamp('scheduled_end', { withTimezone: true }),
  actualStart: timestamp('actual_start', { withTimezone: true }),
  actualEnd: timestamp('actual_end', { withTimezone: true }),

  estimatedDuration: integer('estimated_duration'),
  progress: real('progress').default(0),

  isRecurring: pgBoolean('is_recurring').default(false),
  context: jsonb('context').$type<Record<string, any>>(),
  tools: jsonb('tools').$type<string[]>(),
  metadata: jsonb('metadata').$type<Record<string, any>>(),
  summary: text('summary'),
  resultContent: jsonb('result_content').$type<any>(),

  createdAt: timestamp('created_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
});

/* ─────────────────────────  TASK DEPENDENCY  ───────────────────────── */

export const taskDependency = pgTable('task_dependency', {
  id: uuid('id')
    .default(sql`uuid_generate_v4()`)
    .primaryKey(),

  dependentTaskId: uuid('dependent_task_id')
    .notNull()
    .references(() => task.taskId, { onDelete: 'cascade' }),

  dependencyTaskId: uuid('dependency_task_id')
    .notNull()
    .references(() => task.taskId, { onDelete: 'cascade' }),

  dependencyType: text('dependency_type').default('finish_to_start'),

  createdAt: timestamp('created_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
});

/* ─────────────────────────  TOOL  ───────────────────────── */

export const tool = pgTable('tool', {
  toolId: uuid('tool_id')
    .default(sql`uuid_generate_v4()`)
    .primaryKey(),

  name: text().notNull(),

  schema: jsonb().notNull().$type<
    ChatCompletionTool & {
      apiSpec?: {
        baseUrl: string;
        path: string;
        method: string; // GET, POST, PUT, ...
        headers?: Record<string, string>;
        queryParams?: Record<string, string>;
        bodyTemplate?: any;
      };
    }
  >(),

  tags: jsonb('tags').$type<string[]>(),
  rating: jsonb('ratings'),
  version: text('version'),

  createdAt: timestamp('created_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
});

/* ─────────────────────────  RESOURCE  ───────────────────────── */

export const resource = pgTable('resource', {
  resourceId: text('resource_id')
    .default(sql`uuid_generate_v4()`)
    .primaryKey(),

  resourceType: text('resource_type').notNull(),

  schema: jsonb('schema').notNull().$type<any>(),
  tags: jsonb().notNull().$type<string[]>(),
  resourceFile: text('resource_file').notNull(),

  createdAt: timestamp('created_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
});

/* ─────────────────────────  AGENT LOG  ───────────────────────── */

export const agentLog = pgTable('agent_log', {
  logId: uuid('log_id')
    .default(sql`uuid_generate_v4()`)
    .primaryKey(),

  agentId: text('agent_id')
    .notNull()
    .references(() => agent.agentId, { onDelete: 'cascade' }),

  sessionId: uuid('session_id').references(() => session.sessionId, {
    onDelete: 'cascade',
  }),

  action: text('action'),
  message: text('message'),
  status: text('status'),
  responseTime: integer('response_time'),
  tools: jsonb('tools').$type<
    Array<{
      name: string;
      status: string;
      summary?: string;
      duration?: number;
    }>
  >(),

  createdAt: timestamp('created_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
});

/* ─────────────────────────  AGENT PREFERRED CONNECTION  ───────────────────────── */

export const agentPreferredConnection = pgTable('agent_preferred_connection', {
  id: uuid('id')
    .default(sql`uuid_generate_v4()`)
    .primaryKey(),

  agentId: text('agent_id')
    .notNull()
    .references(() => agent.agentId, { onDelete: 'cascade' }),

  preferredAgentId: text('preferred_agent_id')
    .notNull()
    .references(() => agent.agentId, { onDelete: 'cascade' }),

  usageComments: text('usage_comments'),

  createdAt: timestamp('created_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
});

/* ─────────────────────────  AGENT TOOL (mapping)  ───────────────────────── */

export const agentTool = pgTable('agent_tool', {
  id: uuid('id')
    .default(sql`uuid_generate_v4()`)
    .primaryKey(),

  agentId: text('agent_id')
    .notNull()
    .references(() => agent.agentId, { onDelete: 'cascade' }),

  toolId: uuid('tool_id')
    .notNull()
    .references(() => tool.toolId, { onDelete: 'cascade' }),

  usageComments: text('usage_comments'),
  secureKeyRef: text('secure_key_ref'), // reference to encrypted key store

  createdAt: timestamp('created_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
});

/* ─────────────────────────  SPACE  ───────────────────────── */

export const space = pgTable('space', {
  spaceId: uuid('space_id')
    .default(sql`uuid_generate_v4()`)
    .primaryKey(),

  name: text('name').notNull(),
  description: text('description'),

  createdBy: text('created_by').notNull(), // agentId or userId
  createdByType: text('created_by_type').notNull(), // 'agent' or 'human'

  // Optional connection to a session
  sessionId: uuid('session_id').references(() => session.sessionId, {
    onDelete: 'set null',
  }),

  isPublic: pgBoolean('is_public').default(false).notNull(),
  maxMembers: integer('max_members').default(50),

  settings: jsonb('settings').$type<{
    allowAgents?: boolean;
    allowHumans?: boolean;
    requireApproval?: boolean;
    moderators?: string[];
  }>(),

  createdAt: timestamp('created_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
});

/* ─────────────────────────  SPACE MEMBER  ───────────────────────── */

export const spaceMember = pgTable('space_member', {
  id: uuid('id')
    .default(sql`uuid_generate_v4()`)
    .primaryKey(),

  spaceId: uuid('space_id')
    .notNull()
    .references(() => space.spaceId, { onDelete: 'cascade' }),

  memberId: text('member_id').notNull(), // agentId or userId
  memberType: text('member_type').notNull(), // 'agent' or 'human'
  role: text('role').default('member'),

  status: text('status').default('active'),
  permissions: jsonb('permissions').$type<{
    canWrite?: boolean;
    canInvite?: boolean;
    canModerate?: boolean;
  }>(),

  joinedAt: timestamp('joined_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
  lastActiveAt: timestamp('last_active_at', { withTimezone: true }),
  isSubscribed: pgBoolean('is_subscribed').default(false).notNull(),
});

/* ─────────────────────────  SPACE MESSAGE  ───────────────────────── */

export const spaceMessage = pgTable('space_message', {
  messageId: uuid('message_id')
    .default(sql`uuid_generate_v4()`)
    .primaryKey(),

  spaceId: uuid('space_id')
    .notNull()
    .references(() => space.spaceId, { onDelete: 'cascade' }),

  senderId: text('sender_id').notNull(), // agentId or userId
  senderType: text('sender_type').notNull(), // 'agent' or 'human'

  targetType: text('target_type').default('broadcast'), // 'broadcast', 'direct', 'group'
  targetIds: jsonb('target_ids').$type<string[]>(),

  content: text('content').notNull(),
  messageType: text('message_type').default('text'), // 'text', 'image', 'file', 'system'

  metadata: jsonb('metadata').$type<{
    toolCalls?: Array<{
      name: string;
      args: any;
      result?: any;
    }>;
    attachments?: Array<{
      type: string;
      url: string;
      name: string;
    }>;
    replyTo?: string; // messageId
    mentions?: string[]; // member IDs

    // used by your SpaceService to embed agent/session context
    agentId?: string;
    sessionId?: string;
    privateKey?: string;
  }>(),

  isEdited: pgBoolean('is_edited').default(false),
  isDeleted: pgBoolean('is_deleted').default(false),

  createdAt: timestamp('created_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
});

/* ─────────────────────────  RELATIONS  ───────────────────────── */

// session
export const sessionRelations = relations(session, ({ one, many }) => ({
  goals: many(goal),
  tasks: many(task),
  logs: many(agentLog),

  // parent-child (self reference)
  parent: one(session, {
    fields: [session.parentSessionId],
    references: [session.sessionId],
  }),
}));

// goal
export const goalRelations = relations(goal, ({ one, many }) => ({
  session: one(session, {
    fields: [goal.sessionId],
    references: [session.sessionId],
  }),
  agent: one(agent, {
    fields: [goal.agentId],
    references: [agent.agentId],
  }),
  tasks: many(task),
}));

// task
export const taskRelations = relations(task, ({ one }) => ({
  session: one(session, {
    fields: [task.sessionId],
    references: [session.sessionId],
  }),
  goal: one(goal, {
    fields: [task.goalId],
    references: [goal.goalId],
  }),
  agent: one(agent, {
    fields: [task.agentId],
    references: [agent.agentId],
  }),
}));

// agentLog
export const agentLogRelations = relations(agentLog, ({ one }) => ({
  session: one(session, {
    fields: [agentLog.sessionId],
    references: [session.sessionId],
  }),
  agent: one(agent, {
    fields: [agentLog.agentId],
    references: [agent.agentId],
  }),
}));

// space
export const spaceRelations = relations(space, ({ one, many }) => ({
  session: one(session, {
    fields: [space.sessionId],
    references: [session.sessionId],
  }),
  members: many(spaceMember),
  messages: many(spaceMessage),
}));

// spaceMember
export const spaceMemberRelations = relations(spaceMember, ({ one }) => ({
  space: one(space, {
    fields: [spaceMember.spaceId],
    references: [space.spaceId],
  }),
}));

// spaceMessage
export const spaceMessageRelations = relations(spaceMessage, ({ one }) => ({
  space: one(space, {
    fields: [spaceMessage.spaceId],
    references: [space.spaceId],
  }),
}));

// tool mappings
export const agentToolRelations = relations(agentTool, ({ one }) => ({
  agent: one(agent, {
    fields: [agentTool.agentId],
    references: [agent.agentId],
  }),
  tool: one(tool, {
    fields: [agentTool.toolId],
    references: [tool.toolId],
  }),
}));

export const agentPreferredConnectionRelations = relations(
  agentPreferredConnection,
  ({ one }) => ({
    agent: one(agent, {
      fields: [agentPreferredConnection.agentId],
      references: [agent.agentId],
    }),
    preferredAgent: one(agent, {
      fields: [agentPreferredConnection.preferredAgentId],
      references: [agent.agentId],
    }),
  }),
);
