import type { WalletData } from "@coinbase/coinbase-sdk";
import { sql } from "drizzle-orm";
import {
	integer,
	jsonb,
	boolean as pgBoolean,
	pgTable,
	real,
	text,
	timestamp,
	uuid,
} from "drizzle-orm/pg-core";
import type { ChatCompletionTool } from "openai/resources/chat/completions";

// agent table
export const agent = pgTable("agent", {
	agentId: text("agent_id").default(sql`uuid_generate_v4()`).primaryKey(),
	wallet: jsonb().notNull().$type<WalletData>(),
	instructions: text(),
	persona: text(),
	owner: text(),
	name: text().notNull(),
	knowledgebase: text(),
	externalTools: jsonb("external_tools").$type<string[]>(),
	commonTools: jsonb("common_tools").$type<string[]>(),
	temperature: real("temperature"),
	maxTokens: integer("max_tokens"),
	topP: real("top_p"),
	presencePenalty: real("presence_penalty"),
	frequencyPenalty: real("frequency_penalty"),
	stopSequence: jsonb("stop_sequence").$type<string[]>(),
	avatar: text(),

	// Liaison columns – we store only the hash of the liaison_key
	isLiaison: pgBoolean("is_liaison").default(false).notNull(),
	liaisonKeyHash: text("liaison_key"),
	liaisonKeyDisplay: text("liaison_key_display"),
	externalUrl: text("external_url"),
	externalEndpoint: text("external_endpoint"),

	/* ▼ autonomous‑mode settings ▼ */
	autonomyEnabled: pgBoolean("autonomy_enabled").default(false).notNull(),
	autonomousIntervalSec: integer("autonomous_interval_sec").default(0), // 0 = off
	cronJobName: text("cron_job_name"),

	createdAt: timestamp("created_at", { withTimezone: true })
		.default(sql`timezone('utc', now())`)
		.notNull(),
});

export const memory = pgTable("memory", {
	memoryId: uuid("memory_id").default(sql`uuid_generate_v4()`).primaryKey(),
	agentId: text("agent_id"),
	userId: text("user_id"),
	sessionId: uuid("session_id"),
	content: text("content").notNull(),
	createdAt: timestamp("created_at", { withTimezone: true })
		.default(sql`timezone('utc', now())`)
		.notNull(),
});

//agent goal table
export const goal = pgTable("goal", {
	goalId: uuid("goal_id").default(sql`uuid_generate_v4()`).primaryKey(),
	agentId: text("agent_id").notNull(),
	sessionId: uuid("session_id").references(() => session.sessionId, {
		onDelete: "cascade",
	}),

	title: text("title").notNull(),
	description: text("description"),

	status: text("status").default("pending").notNull(), // pending | started | paused | completed | failed
	priority: integer("priority").default(0).notNull(),
	deadline: timestamp("deadline", { withTimezone: true }),
	progress: real("progress").default(0),
	isAutoGenerated: pgBoolean("is_auto_generated").default(false),
	metadata: jsonb("metadata").$type<Record<string, any>>(),

	createdAt: timestamp("created_at", { withTimezone: true })
		.default(sql`timezone('utc', now())`)
		.notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true })
		.default(sql`timezone('utc', now())`)
		.notNull(),
	completedAt: timestamp("completed_at", { withTimezone: true }),
});

// agent task table
export const task = pgTable("task", {
	taskId: uuid("task_id").default(sql`uuid_generate_v4()`).primaryKey(),
	agentId: text("agent_id").notNull(),
	goalId: uuid("goal_id").notNull(),
	sessionId: uuid("session_id").references(() => session.sessionId, {
		onDelete: "cascade",
	}),

	title: text("title").notNull(),
	description: text("description"),

	status: text("status").default("pending").notNull(), // pending | started | …
	priority: integer("priority").default(0).notNull(),

	scheduledStart: timestamp("scheduled_start", { withTimezone: true }),
	scheduledEnd: timestamp("scheduled_end", { withTimezone: true }),
	actualStart: timestamp("actual_start", { withTimezone: true }),
	actualEnd: timestamp("actual_end", { withTimezone: true }),

	estimatedDuration: integer("estimated_duration"),
	progress: real("progress").default(0),

	isRecurring: pgBoolean("is_recurring").default(false),
	context: jsonb("context").$type<Record<string, any>>(),
	tools: jsonb("tools").$type<string[]>(),
	metadata: jsonb("metadata").$type<Record<string, any>>(),
	summary: text("summary"),
	resultContent: jsonb("result_content").$type<any>(),

	createdAt: timestamp("created_at", { withTimezone: true })
		.default(sql`timezone('utc', now())`)
		.notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true })
		.default(sql`timezone('utc', now())`)
		.notNull(),
});

// agent task dependency table
export const taskDependency = pgTable("task_dependency", {
	id: uuid("id").default(sql`uuid_generate_v4()`).primaryKey(),
	dependentTaskId: uuid("dependent_task_id").notNull(),
	dependencyTaskId: uuid("dependency_task_id").notNull(),
	dependencyType: text("dependency_type").default("finish_to_start"),
	createdAt: timestamp("created_at", { withTimezone: true })
		.default(sql`timezone('utc', now())`)
		.notNull(),
});

// agent tool table
export const tool = pgTable("tool", {
	toolId: uuid("tool_id").default(sql`uuid_generate_v4()`).primaryKey(),

	// The "name" must match the function's "name" field
	name: text().notNull(),

	/**
	 * The schema is a JSON column, and we'll store:
	 * - The "function" shape (name, description, parameters)
	 * - The "apiSpec" that describes how to call the external API
	 */
	schema: jsonb().notNull().$type<
		ChatCompletionTool & {
			apiSpec?: {
				baseUrl: string;
				path: string;
				method: string; // GET, POST, PUT, ...
				headers?: Record<string, string>;
				queryParams?: Record<string, string>;
				bodyTemplate?: any;
			};
		}
	>(),

	tags: jsonb("tags").$type<string[]>(),
	rating: jsonb("ratings"),
	version: text("version"),

	createdAt: timestamp("created_at", { withTimezone: true })
		.default(sql`timezone('utc', now())`)
		.notNull(),
});

export const agentTool = pgTable("agent_tool", {
	id: uuid().default(sql`uuid_generate_v4()`).primaryKey(),

	agentId: text("agent_id")
		.notNull()
		.references(() => agent.agentId, { onDelete: "cascade" }),

	toolId: uuid("tool_id")
		.notNull()
		.references(() => tool.toolId, { onDelete: "cascade" }),

	usageComments: text("usage_comments"),
	secureKeyRef: text("secure_key_ref"), // reference to encrypted key store

	createdAt: timestamp("created_at", { withTimezone: true })
		.default(sql`timezone('utc', now())`)
		.notNull(),
});

export const space = pgTable("space", {
	spaceId: uuid("space_id").default(sql`uuid_generate_v4()`).primaryKey(),

	name: text("name").notNull(),
	description: text("description"),

	createdBy: text("created_by").notNull(), // agentId or userId
	createdByType: text("created_by_type").notNull(), // 'agent' or 'human'

	// Optional connection to a session
	sessionId: uuid("session_id").references(() => session.sessionId, {
		onDelete: "set null",
	}),

	isPublic: pgBoolean("is_public").default(false).notNull(),
	maxMembers: integer("max_members").default(50),

	settings: jsonb("settings").$type<{
		allowAgents?: boolean;
		allowHumans?: boolean;
		requireApproval?: boolean;
		moderators?: string[];
	}>(),

	createdAt: timestamp("created_at", { withTimezone: true })
		.default(sql`timezone('utc', now())`)
		.notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true })
		.default(sql`timezone('utc', now())`)
		.notNull(),
});

export const spaceMember = pgTable("space_member", {
	id: uuid().default(sql`uuid_generate_v4()`).primaryKey(),

	spaceId: uuid("space_id")
		.notNull()
		.references(() => space.spaceId, { onDelete: "cascade" }),

	memberId: text("member_id").notNull(), // agentId or userId
	memberType: text("member_type").notNull(), // 'agent' or 'human'
	role: text().default("member"),

	status: text().default("active"),
	permissions: jsonb().$type<{
		canWrite?: boolean;
		canInvite?: boolean;
		canModerate?: boolean;
	}>(),

	joinedAt: timestamp("joined_at", { withTimezone: true })
		.default(sql`timezone('utc', now())`)
		.notNull(),
	lastActiveAt: timestamp("last_active_at", { withTimezone: true }),
	isSubscribed: pgBoolean("is_subscribed").default(false).notNull(),
});

export const resource = pgTable("resource", {
	resourceId: text("resource_id").default(sql`uuid_generate_v4()`).primaryKey(),

	resourceType: text("resource_type").notNull(),

	schema: jsonb("schema").notNull().$type<any>(),
	tags: jsonb().notNull().$type<string[]>(),
	resourceFile: text("resource_file").notNull(),

	createdAt: timestamp("created_at", { withTimezone: true })
		.default(sql`timezone('utc', now())`)
		.notNull(),
});

//session table
export const session = pgTable("session", {
	sessionId: uuid("session_id").default(sql`uuid_generate_v4()`).primaryKey(),
	agentId: text("agent_id").notNull(),
	userId: text("user_id"),
	spaceId: text("space_id"),
	//status: text('status').default('active').notNull(), // active | completed | failed | terminated
	title: text("title"),
	initiator: text("initiator"), // wallet address of user or agent
	model: jsonb("model").$type<{
		name: string;
		temperature?: number;
		maxTokens?: number;
		topP?: number;
		presencePenalty?: number;
		frequencyPenalty?: number;
	}>(),
	query: jsonb("query").$type<{
		text: string;
		timestamp: string;
		metadata?: Record<string, any>;
	}>(),
	history:
		jsonb("history").$type<
			Array<{
				role: string;
				content: string;
				timestamp: string;
				metadata?: Record<string, any>;
			}>
		>(),
	metrics: jsonb("metrics").$type<{
		totalTokens?: number;
		responseTime?: number;
		toolCalls?: number;
		errorCount?: number;
	}>(),
	endedAt: timestamp("ended_at", { withTimezone: true }),

	parentSessionId: text("parent_session"),
	createdAt: timestamp("created_at", { withTimezone: true })
		.default(sql`timezone('utc', now())`)
		.notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true })
		.default(sql`timezone('utc', now())`)
		.notNull(),
});

// agent log table
export const agentLog = pgTable("agent_log", {
	logId: uuid("log_id").default(sql`uuid_generate_v4()`).primaryKey(),
	agentId: text("agent_id").notNull(),
	sessionId: uuid("session_id").references(() => session.sessionId, {
		onDelete: "cascade",
	}),
	action: text("action"),
	message: text("message"),
	status: text("status"),
	responseTime: integer("response_time"),
	tools:
		jsonb("tools").$type<
			Array<{
				name: string;
				status: string;
				summary?: string;
				duration?: number;
			}>
		>(),

	createdAt: timestamp("created_at", { withTimezone: true })
		.default(sql`timezone('utc', now())`)
		.notNull(),
});
