import {
  jsonb,
  pgTable,
  timestamp,
  uuid,
  text,
  integer,
  real,
  boolean as pgBoolean,
} from 'drizzle-orm/pg-core';
import { sql } from 'drizzle-orm';
import { ChatCompletionTool } from 'openai/resources/chat/completions';
import { WalletData } from '@coinbase/coinbase-sdk';

// agent table
export const agent = pgTable('agent', {
  agentId: text('agent_id')
    .default(sql`uuid_generate_v4()`)
    .primaryKey(),
  wallet: jsonb().notNull().$type<WalletData>(),
  instructions: text(),
  persona: text(),
  owner: text(),
  name: text().notNull(),
  knowledgebase: jsonb('knowledgebase').$type<
    Array<{
      title: string;
      content: string;
      usageComments?: string;
    }>
  >(),
  externalTools: jsonb('external_tools').$type<string[]>(),
  commonTools: jsonb('common_tools').$type<string[]>(),
  temperature: real('temperature'),
  maxTokens: integer('max_tokens'),
  topP: real('top_p'),
  presencePenalty: real('presence_penalty'),
  frequencyPenalty: real('frequency_penalty'),
  stopSequence: jsonb('stop_sequence').$type<string[]>(),
  avatar: text(),

  // Liaison columns – we store only the hash of the liaison_key
  isLiaison: pgBoolean('is_liaison').default(false).notNull(),
  liaisonKeyHash: text('liaison_key'),
  externalUrl: text('external_url'),
  externalEndpoint: text('external_endpoint'),

  /* ▼ autonomous‑mode settings ▼ */
  autonomyEnabled: pgBoolean('autonomy_enabled').default(false).notNull(),
  autonomousIntervalSec: integer('autonomous_interval_sec').default(0), // 0 = off
  cronJobName: text('cron_job_name'),

  createdAt: timestamp('created_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
});

//agent goal table
export const goal = pgTable('goal', {
  goalId: uuid('goal_id')
    .default(sql`uuid_generate_v4()`)
    .primaryKey(),
  agentId: text('agent_id').notNull(),
  sessionId: uuid('session_id').references(() => session.sessionId, {
    onDelete: 'cascade',
  }),

  title: text('title').notNull(),
  description: text('description'),

  status: text('status').default('pending').notNull(), // pending | started | paused | completed | failed
  priority: integer('priority').default(0).notNull(),
  deadline: timestamp('deadline', { withTimezone: true }),
  progress: real('progress').default(0),
  isAutoGenerated: pgBoolean('is_auto_generated').default(false),
  metadata: jsonb('metadata').$type<Record<string, any>>(),

  createdAt: timestamp('created_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
  completedAt: timestamp('completed_at', { withTimezone: true }),
});

// agent task table
export const task = pgTable('task', {
  taskId: uuid('task_id')
    .default(sql`uuid_generate_v4()`)
    .primaryKey(),
  agentId: text('agent_id').notNull(),
  goalId: uuid('goal_id').notNull(),
  sessionId: uuid('session_id').references(() => session.sessionId, {
    onDelete: 'cascade',
  }),

  title: text('title').notNull(),
  description: text('description'),

  status: text('status').default('pending').notNull(), // pending | started | …
  priority: integer('priority').default(0).notNull(),

  scheduledStart: timestamp('scheduled_start', { withTimezone: true }),
  scheduledEnd: timestamp('scheduled_end', { withTimezone: true }),
  actualStart: timestamp('actual_start', { withTimezone: true }),
  actualEnd: timestamp('actual_end', { withTimezone: true }),

  estimatedDuration: integer('estimated_duration'),
  progress: real('progress').default(0),

  isRecurring: pgBoolean('is_recurring').default(false),
  context: jsonb('context').$type<Record<string, any>>(),
  tools: jsonb('tools').$type<string[]>(),
  metadata: jsonb('metadata').$type<Record<string, any>>(),
  summary: text('summary'),
  resultContent: jsonb('result_content').$type<any>(),

  createdAt: timestamp('created_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
});

// agent task dependency table
export const taskDependency = pgTable('task_dependency', {
  id: uuid('id')
    .default(sql`uuid_generate_v4()`)
    .primaryKey(),
  dependentTaskId: uuid('dependent_task_id').notNull(),
  dependencyTaskId: uuid('dependency_task_id').notNull(),
  dependencyType: text('dependency_type').default('finish_to_start'),
  createdAt: timestamp('created_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
});

// agent tool table
export const tool = pgTable('tool', {
  toolId: uuid('tool_id')
    .default(sql`uuid_generate_v4()`)
    .primaryKey(),

  // The "name" must match the function's "name" field
  name: text().notNull(),

  /**
   * The schema is a JSON column, and we'll store:
   * - The "function" shape (name, description, parameters)
   * - The "apiSpec" that describes how to call the external API
   */
  schema: jsonb().notNull().$type<
    ChatCompletionTool & {
      apiSpec?: {
        baseUrl: string;
        path: string;
        method: string; // GET, POST, PUT, ...
        headers?: Record<string, string>;
        queryParams?: Record<string, string>;
        bodyTemplate?: any;
      };
    }
  >(),

  tags: jsonb('tags').$type<string[]>(),
  rating: jsonb('ratings'),
  version: text('version'),

  createdAt: timestamp('created_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
});

export const resource = pgTable('resource', {
  resourceId: text('resource_id')
    .default(sql`uuid_generate_v4()`)
    .primaryKey(),

  resourceType: text('resource_type').notNull(),

  schema: jsonb('schema').notNull().$type<any>(),
  tags: jsonb().notNull().$type<string[]>(),
  resourceFile: text('resource_file').notNull(),

  createdAt: timestamp('created_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
});

//session table
export const session = pgTable('session', {
  sessionId: uuid('session_id')
    .default(sql`uuid_generate_v4()`)
    .primaryKey(),
  agentId: text('agent_id').notNull(),
  //status: text('status').default('active').notNull(), // active | completed | failed | terminated
  title: text('title'),
  initiator: text('initiator'), // wallet address of user or agent
  model: jsonb('model').$type<{
    name: string;
    temperature?: number;
    maxTokens?: number;
    topP?: number;
    presencePenalty?: number;
    frequencyPenalty?: number;
  }>(),
  query: jsonb('query').$type<{
    text: string;
    timestamp: string;
    metadata?: Record<string, any>;
  }>(),
  history: jsonb('history').$type<
    Array<{
      role: string;
      content: string;
      timestamp: string;
      metadata?: Record<string, any>;
    }>
  >(),
  metrics: jsonb('metrics').$type<{
    totalTokens?: number;
    responseTime?: number;
    toolCalls?: number;
    errorCount?: number;
  }>(),
  endedAt: timestamp('ended_at', { withTimezone: true }),
  spaces: jsonb('spaces').$type<{ spaceIds: string[] }>(), // array of space IDs
  parentSessionId: text('parent_session'),
  createdAt: timestamp('created_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
});

// agent log table
export const agentLog = pgTable('agent_log', {
  logId: uuid('log_id')
    .default(sql`uuid_generate_v4()`)
    .primaryKey(),
  agentId: text('agent_id').notNull(),
  sessionId: uuid('session_id').references(() => session.sessionId, {
    onDelete: 'cascade',
  }),
  action: text('action'),
  message: text('message'),
  status: text('status'),
  responseTime: integer('response_time'),
  tools: jsonb('tools').$type<
    Array<{
      name: string;
      status: string;
      summary?: string;
      duration?: number;
    }>
  >(),

  createdAt: timestamp('created_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
});

// 4. New table: agent_preferred_connections
export const agentPreferredConnection = pgTable('agent_preferred_connection', {
  id: uuid('id')
    .default(sql`uuid_generate_v4()`)
    .primaryKey(),
  agentId: text('agent_id').notNull(),
  preferredAgentId: text('preferred_agent_id').notNull(),
  usageComments: text('usage_comments'),
  createdAt: timestamp('created_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
});

// 5. New table: agent_tools (agent-tool mapping with details)
export const agentTool = pgTable('agent_tool', {
  id: uuid('id')
    .default(sql`uuid_generate_v4()`)
    .primaryKey(),
  agentId: text('agent_id').notNull(),
  toolId: text('tool_id').notNull(),
  usageComments: text('usage_comments'),
  secureKeyRef: text('secure_key_ref'), // reference to encrypted key store
  createdAt: timestamp('created_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
});

// Space table for shared communication bus
export const space = pgTable('space', {
  spaceId: uuid('space_id')
    .default(sql`uuid_generate_v4()`)
    .primaryKey(),
  name: text('name').notNull(),
  description: text('description'),
  createdBy: text('created_by').notNull(), // agentId or userId
  createdByType: text('created_by_type').notNull(), // 'agent' or 'human'

  // Optional connection to a session
  sessionId: uuid('session_id').references(() => session.sessionId, {
    onDelete: 'set null',
  }),

  // Space metadata
  isPublic: pgBoolean('is_public').default(false).notNull(),
  maxMembers: integer('max_members').default(50), // null means unlimited

  // Space settings
  settings: jsonb('settings').$type<{
    allowAgents?: boolean;
    allowHumans?: boolean;
    requireApproval?: boolean;
    moderators?: string[];
  }>(),

  createdAt: timestamp('created_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
});

// Space membership table
export const spaceMember = pgTable('space_member', {
  id: uuid('id')
    .default(sql`uuid_generate_v4()`)
    .primaryKey(),
  spaceId: uuid('space_id')
    .references(() => space.spaceId, { onDelete: 'cascade' })
    .notNull(),
  memberId: text('member_id').notNull(), // agentId or userId
  memberType: text('member_type').notNull(), // 'agent' or 'human'
  role: text('role').default('member'), // 'owner', 'moderator', 'member'

  // Member status
  status: text('status').default('active'), // 'active', 'muted', 'banned'
  permissions: jsonb('permissions').$type<{
    canWrite?: boolean;
    canInvite?: boolean;
    canModerate?: boolean;
  }>(),

  joinedAt: timestamp('joined_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
  lastActiveAt: timestamp('last_active_at', { withTimezone: true }),
});

// Space messages table
export const spaceMessage = pgTable('space_message', {
  messageId: uuid('message_id')
    .default(sql`uuid_generate_v4()`)
    .primaryKey(),
  spaceId: uuid('space_id')
    .references(() => space.spaceId, { onDelete: 'cascade' })
    .notNull(),

  // Message sender
  senderId: text('sender_id').notNull(), // agentId or userId
  senderType: text('sender_type').notNull(), // 'agent' or 'human'

  // Message targeting
  targetType: text('target_type').default('broadcast'), // 'broadcast', 'direct', 'group'
  targetIds: jsonb('target_ids').$type<string[]>(), // For direct messages or group targeting

  // Message content
  content: text('content').notNull(),
  messageType: text('message_type').default('text'), // 'text', 'image', 'file', 'system'

  // Message metadata
  metadata: jsonb('metadata').$type<{
    toolCalls?: Array<{
      name: string;
      args: any;
      result?: any;
    }>;
    attachments?: Array<{
      type: string;
      url: string;
      name: string;
    }>;
    replyTo?: string; // messageId
    mentions?: string[]; // member IDs
  }>(),

  // Message status
  isEdited: pgBoolean('is_edited').default(false),
  isDeleted: pgBoolean('is_deleted').default(false),

  createdAt: timestamp('created_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true })
    .default(sql`timezone('utc', now())`)
    .notNull(),
});
