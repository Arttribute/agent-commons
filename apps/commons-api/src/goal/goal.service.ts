import { Injectable, NotFoundException } from '@nestjs/common';
import { DatabaseService } from '~/modules/database/database.service';
import { and, eq, not, sql } from 'drizzle-orm';
import { v4 as uuid } from 'uuid';
import * as schema from '#/models/schema';

type Status = 'pending' | 'started' | 'completed' | 'failed';
type Priority = 1 | 2 | 3 | 4 | 5;

export interface CreateGoalDto {
  agentId: string;
  sessionId: string;
  title: string;
  description?: string;
  priority?: Priority;
  deadline?: Date;
  isAutoGenerated?: boolean;
  metadata?: Record<string, any>;
}

@Injectable()
export class GoalService {
  constructor(private readonly db: DatabaseService) {}

  async create(dto: CreateGoalDto) {
    const [row] = await this.db
      // @ts-expect-error - goal table is deprecated but kept for backward compatibility
      .insert(schema.goal)
      .values({
        goalId: uuid(),
        agentId: dto.agentId,
        sessionId: dto.sessionId,
        title: dto.title,
        description: dto.description,
        priority: dto.priority ?? 2,
        deadline: dto.deadline ? new Date(dto.deadline) : new Date(),
        status: 'pending',
        progress: 0,
        isAutoGenerated: dto.isAutoGenerated,
        metadata: dto.metadata,
      })
      .returning();
    return row;
  }
  //get next executable goal
  async getNextExecutableGoal(agentId: string) {
    // @ts-expect-error - goal table is deprecated but kept for backward compatibility
    const row = await this.db.query.goal.findFirst({
      where: (g: any) =>
        and(
          eq(g.agentId, agentId),
          not(eq(g.status, 'completed')),
          not(eq(g.status, 'failed')),
          eq(g.isAutoGenerated, false),
        ),
      orderBy: (g: any) => g.priority,
    });
    return row;
  }

  async recomputeProgress(goalId: string) {
    const [{ value }] = await this.db
      .select({
        value: sql<number>`COALESCE(AVG(${schema.task.progress}),0)`,
      })
      .from(schema.task)
      // @ts-expect-error - goalId field is deprecated
      .where(eq(schema.task.goalId, goalId));
    await this.db
      // @ts-expect-error - goal table is deprecated but kept for backward compatibility
      .update(schema.goal)
      .set({ progress: value, updatedAt: new Date() })
      // @ts-expect-error - goal table is deprecated but kept for backward compatibility
      .where(eq(schema.goal.goalId, goalId));
  }

  //update goal progress and status and completedAt if completed
  async updateProgress(goalId: string, progress: number, status: Status) {
    await this.db
      // @ts-expect-error - goal table is deprecated but kept for backward compatibility
      .update(schema.goal)
      .set({
        progress,
        status,
        updatedAt: new Date(),
        ...(status === 'completed' ? { completedAt: new Date() } : {}),
      })
      // @ts-expect-error - goal table is deprecated but kept for backward compatibility
      .where(eq(schema.goal.goalId, goalId));
  }

  async get(goalId: string) {
    // @ts-expect-error - goal table is deprecated but kept for backward compatibility
    const row = await this.db.query.goal.findFirst({
      where: (g: any) => eq(g.goalId, goalId),
    });
    if (!row) throw new NotFoundException('Goal not found');
    return row;
  }
}
