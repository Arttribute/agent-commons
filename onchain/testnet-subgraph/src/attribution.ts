import {
  Attribution as AttributionContract,
  AttributionRecorded as AttributionRecordedEvent,
  RoleAdminChanged as RoleAdminChangedEvent,
  RoleGranted as RoleGrantedEvent,
  RoleRevoked as RoleRevokedEvent,
} from "../generated/Attribution/Attribution";
import {
  Attribution as AttributionEntity,
  AttributionCitation,
  RoleAdminChanged,
  RoleGranted,
  RoleRevoked,
} from "../generated/schema";

export function handleAttributionRecorded(
  event: AttributionRecordedEvent
): void {
  // Use the resourceId (as string) as the entity id.
  let id = event.params.resourceId.toString();
  let contract = AttributionContract.bind(event.address);

  // Call the public getter for the attribution record.
  // (Assumes your ABI includes the autogenerated getter for the mapping `attributions`)
  let attributionRecord = contract.attributions(event.params.resourceId);

  let attribution = new AttributionEntity(id);
  attribution.resourceId = event.params.resourceId;
  attribution.parentResources = [attributionRecord.value1];

  // Convert numeric relation types to strings.
  let relationTypesArray = attributionRecord.value0;
  let relationTypesStr: Array<string> = [];
  for (let i = 0; i < relationTypesArray.length; i++) {
    let rel = relationTypesArray[i];
    if (rel == 0) {
      relationTypesStr.push("DERIVED_FROM");
    } else if (rel == 1) {
      relationTypesStr.push("INSPIRED_BY");
    } else if (rel == 2) {
      relationTypesStr.push("USES");
    } else if (rel == 3) {
      relationTypesStr.push("COLLABORATED_WITH");
    } else {
      relationTypesStr.push("UNKNOWN");
    }
  }
  attribution.relationTypes = relationTypesStr;
  attribution.contributionDescriptions = [];
  attribution.timestamp = attributionRecord.getTimestamp();
  // Fetch derivatives via the contract call.
  attribution.derivatives = contract.getDerivatives(event.params.resourceId);
  attribution.save();

  // Fetch citations from the contract.
  let citationsArray = contract.getCitations(event.params.resourceId);
  for (let i = 0; i < citationsArray.length; i++) {
    let citation = citationsArray[i];
    let citationId = id + "-" + i.toString();
    let attributionCitation = new AttributionCitation(citationId);
    attributionCitation.attribution = id;
    attributionCitation.citingResourceId = citation.citingResourceId;
    attributionCitation.citedResourceId = citation.citedResourceId;
    attributionCitation.description = citation.description;
    attributionCitation.timestamp = citation.timestamp;
    attributionCitation.save();
  }
}
export function handleRoleAdminChanged(event: RoleAdminChangedEvent): void {
  let entity = new RoleAdminChanged(
    event.transaction.hash.concatI32(event.logIndex.toI32())
  );
  entity.role = event.params.role;
  entity.previousAdminRole = event.params.previousAdminRole;
  entity.newAdminRole = event.params.newAdminRole;

  entity.blockNumber = event.block.number;
  entity.blockTimestamp = event.block.timestamp;
  entity.transactionHash = event.transaction.hash;

  entity.save();
}

export function handleRoleGranted(event: RoleGrantedEvent): void {
  let entity = new RoleGranted(
    event.transaction.hash.concatI32(event.logIndex.toI32())
  );
  entity.role = event.params.role;
  entity.account = event.params.account;
  entity.sender = event.params.sender;

  entity.blockNumber = event.block.number;
  entity.blockTimestamp = event.block.timestamp;
  entity.transactionHash = event.transaction.hash;

  entity.save();
}

export function handleRoleRevoked(event: RoleRevokedEvent): void {
  let entity = new RoleRevoked(
    event.transaction.hash.concatI32(event.logIndex.toI32())
  );
  entity.role = event.params.role;
  entity.account = event.params.account;
  entity.sender = event.params.sender;

  entity.blockNumber = event.block.number;
  entity.blockTimestamp = event.block.timestamp;
  entity.transactionHash = event.transaction.hash;

  entity.save();
}
